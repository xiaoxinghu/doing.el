#+STARTUP: show2levels

* Phase 1: Foundation

Infrastructure-level code that all other features depend on.

** DONE Package skeleton and configuration
:PROPERTIES:
:ID:       7DD06887-C2A1-41DE-B2EF-581260FB1715
:CLAUDE_TIME_MS: 435
:CLAUDE_INPUT_TOKENS: 0
:CLAUDE_OUTPUT_TOKENS: 0
:CLAUDE_SESSION_ID: ea0b9a16-643e-4956-9f89-6b6d4f7c5418
:END:

Set up the main package file with proper headers and customization group.

*** Implementation

**** =doing.el= — main entry point

- Update package headers (name, author, version, dependencies)
- Minimum Emacs version: 27.1 (for =org-element= improvements)
- Dependencies: =org= (built-in)
- Optional: =org-ql= (for enhanced search)
- Define =defgroup doing= with description
- Key customization variables:
  - =doing-directory= (default =~/org/doing/=)
  - =doing-file-today= (default =today.org=)
  - =doing-file-week= (default =week.org=)
  - =doing-archive-directory= (default =archive/=)
  only expose =doing-directory= for user customization for now, leave the rest as internal config.
- End with =(provide 'doing)=

**** Tests

- =doing-test-customization-group-exists=
- =doing-test-directory-default=

** DONE File and directory utilities
:PROPERTIES:
:ID:       9D145A8C-E751-48D1-8E4B-0D75EA07EE68
:CLAUDE_TIME_MS: 161980
:CLAUDE_COST: 0.7328889500000001
:CLAUDE_INPUT_TOKENS: 105
:CLAUDE_OUTPUT_TOKENS: 6636
:CLAUDE_SESSION_ID: c808c9c3-1aae-4cd3-bec1-984a70f37b16
:END:

Create =doing-lib.el= with utilities for file path construction and directory management.

*** Implementation

**** Functions

- =doing--directory ()= — return expanded =doing-directory=, create if needed
- =doing--file-today ()= — return full path to =today.org=
- =doing--file-week ()= — return full path to =week.org=
- =doing--file-archive (year week)= — return path to =archive/YYYY-WNN.org=
- =doing--ensure-directory ()= — create =doing-directory= and =archive/= if missing
- =doing--ensure-file (path &optional title)= — create file with org header if missing

**** Built-in functions to use

- =make-directory= with =parents= arg
- =file-exists-p=, =expand-file-name=

**** Tests

- =doing-test-directory-creation=
- =doing-test-file-paths=
- =doing-test-ensure-file-creates-with-header=

** DONE Timestamp and duration utilities
:PROPERTIES:
:ID:       42F9B711-672A-4648-A9BA-0B3018B8A7A5
:CLAUDE_TIME_MS: 157535
:CLAUDE_COST: 0.61087765
:CLAUDE_INPUT_TOKENS: 68
:CLAUDE_OUTPUT_TOKENS: 6529
:CLAUDE_SESSION_ID: a39ede89-2c48-4e86-9ae9-e8110f0e50fe
:END:

Thin wrappers around built-in functions for our specific needs.

*** Implementation

**** Functions (mostly wrappers)

#+BEGIN_SRC elisp
(defun doing--timestamp-now ()
  "Return current time as Org inactive timestamp."
  (format-time-string "[%Y-%m-%d %a %H:%M]"))

(defun doing--timestamp-to-time (timestamp)
  "Parse Org TIMESTAMP string to Emacs time."
  (org-parse-time-string timestamp))

(defun doing--timestamp-date (timestamp)
  "Extract YYYY-MM-DD from TIMESTAMP."
  (substring timestamp 1 11))

(defun doing--duration-minutes (start-ts end-ts)
  "Compute minutes between START-TS and END-TS timestamps."
  (let ((start (org-parse-time-string start-ts))
        (end (org-parse-time-string end-ts)))
    (/ (float-time (time-subtract (encode-time end) (encode-time start)))
       60.0)))

(defun doing--duration-format (minutes)
  "Format MINUTES as H:MM string."
  (org-duration-from-minutes minutes))  ; <-- USE BUILT-IN!

(defun doing--iso-week (&optional time)
  "Return (YEAR WEEK) for TIME or now."
  (let ((time (or time (current-time))))
    (list (string-to-number (format-time-string "%G" time))
          (string-to-number (format-time-string "%V" time)))))

(defun doing--iso-week-string (&optional time)
  "Return YYYY-WNN string."
  (format-time-string "%G-W%V" (or time (current-time))))
#+END_SRC

**** Key insight

- *Use =org-duration-from-minutes= and =org-duration-to-minutes=* — don't reimplement!
- *Use =format-time-string= with =%V= and =%G=* for ISO week

**** Tests

- =doing-test-timestamp-now-format=
- =doing-test-duration-calculation=
- =doing-test-iso-week-string=

** DONE Entry parsing with org-element
:PROPERTIES:
:ID:       559A5095-73B5-4710-8337-C69A56C6E58D
:CLAUDE_TIME_MS: 179215
:CLAUDE_COST: 0.72489955
:CLAUDE_INPUT_TOKENS: 65
:CLAUDE_OUTPUT_TOKENS: 9213
:CLAUDE_SESSION_ID: 20f0f0de-a963-4ab2-ad10-9505ac9c7af3
:END:

Use =org-element= API to parse entries. *Do not write custom parsers.*

*** Implementation

**** Functions

#+BEGIN_SRC elisp
(defun doing--parse-entry-at-point ()
  "Parse headline at point into entry plist."
  (let ((el (org-element-at-point)))
    (when (eq 'headline (org-element-type el))
      (list :id (org-element-property :ID el)
            :title (org-element-property :raw-value el)
            :tags (org-element-property :tags el)
            :started (org-element-property :STARTED el)
            :ended (org-element-property :ENDED el)
            :project (org-element-property :PROJECT el)
            :begin (org-element-property :begin el)
            :end (org-element-property :end el)))))

(defun doing--parse-buffer ()
  "Return list of entries in current buffer."
  (org-element-map (org-element-parse-buffer 'headline) 'headline
    (lambda (hl)
      (list :id (org-element-property :ID hl)
            :title (org-element-property :raw-value hl)
            :tags (org-element-property :tags hl)
            :started (org-element-property :STARTED hl)
            :ended (org-element-property :ENDED hl)
            :project (org-element-property :PROJECT hl)
            :begin (org-element-property :begin hl)))))

(defun doing--parse-file (path)
  "Return list of entries from file at PATH."
  (when (file-exists-p path)
    (with-temp-buffer
      (insert-file-contents path)
      (org-mode)
      (doing--parse-buffer))))
#+END_SRC

**** Key insight

- =org-element-parse-buffer= with ='headline= granularity is fast
- =org-element-map= handles traversal
- Properties from drawer are available as =:PROPNAME= (uppercase)

**** Tests

- =doing-test-parse-entry-at-point=
- =doing-test-parse-buffer-multiple=
- =doing-test-parse-file=

** DONE Entry serialization — plist to Org
:PROPERTIES:
:ID:       2EF6D87A-A4D3-40B7-BE59-265E2565DE5A
:CLAUDE_TIME_MS: 174957
:CLAUDE_COST: 0.7814329499999997
:CLAUDE_INPUT_TOKENS: 78
:CLAUDE_OUTPUT_TOKENS: 7384
:CLAUDE_SESSION_ID: 0e972248-dc41-4f5c-be66-7d43c82b1893
:END:

Write entry plists as Org headlines using built-in functions.

*** Implementation

**** Functions

#+BEGIN_SRC elisp
(defun doing--entry-to-org (entry)
  "Convert ENTRY plist to Org headline string."
  (let ((title (plist-get entry :title))
        (tags (plist-get entry :tags))
        (id (plist-get entry :id))
        (started (plist-get entry :started))
        (ended (plist-get entry :ended))
        (project (plist-get entry :project))
        (body (plist-get entry :body)))
    (concat
     "* " title
     (when tags
       (concat " :" (mapconcat #'identity tags ":") ":"))
     "\n"
     ":PROPERTIES:\n"
     (format ":ID:       %s\n" id)
     (format ":STARTED:  %s\n" started)
     (when ended (format ":ENDED:    %s\n" ended))
     (when ended
       (format ":DURATION: %s\n"
               (doing--duration-format
                (doing--duration-minutes started ended))))
     (when project (format ":PROJECT:  %s\n" project))
     ":END:\n"
     (when body (concat body "\n")))))

(defun doing--append-entry-to-file (entry path)
  "Append ENTRY to file at PATH."
  (doing--ensure-file path)
  (with-temp-buffer
    (insert (doing--entry-to-org entry))
    (append-to-file (point-min) (point-max) path)))
#+END_SRC

**** Tests

- =doing-test-entry-to-org-minimal=
- =doing-test-entry-to-org-with-tags=
- =doing-test-append-entry-to-file=

** DONE Entry modification using org-entry API
:PROPERTIES:
:ID:       5C9C0A9D-BD5D-42AE-9418-3DEEC8AA2AEB
:CLAUDE_TIME_MS: 222097
:CLAUDE_COST: 0.9346406000000002
:CLAUDE_INPUT_TOKENS: 72
:CLAUDE_OUTPUT_TOKENS: 11062
:CLAUDE_SESSION_ID: b2debe50-71f5-4708-90d9-8a6e22b95d4a
:END:

Use =org-entry-put= and =org-entry-get= for modifications. *Do not use regex.*

*** Implementation

**** Functions

#+BEGIN_SRC elisp
(defun doing--goto-entry (id &optional file)
  "Go to entry with ID in FILE (default today.org). Return point or nil."
  (let ((file (or file (doing--file-today))))
    (when (file-exists-p file)
      (with-current-buffer (find-file-noselect file)
        (goto-char (point-min))
        (when (re-search-forward
               (format "^:ID: +%s$" (regexp-quote id)) nil t)
          (org-back-to-heading t)
          (point))))))

(defun doing--update-entry-property (id property value &optional file)
  "Set PROPERTY to VALUE for entry with ID."
  (let ((file (or file (doing--file-today))))
    (with-current-buffer (find-file-noselect file)
      (save-excursion
        (when (doing--goto-entry id file)
          (org-entry-put nil property value)  ; <-- USE BUILT-IN!
          (save-buffer))))))

(defun doing--delete-entry (id &optional file)
  "Delete entry with ID from FILE."
  (let ((file (or file (doing--file-today))))
    (with-current-buffer (find-file-noselect file)
      (save-excursion
        (when (doing--goto-entry id file)
          (org-cut-subtree)
          (save-buffer))))))
#+END_SRC

**** Key insight

- =org-entry-put= and =org-entry-get= handle property drawer automatically
- =org-back-to-heading= navigates reliably
- =org-cut-subtree= removes entire entry

**** Tests

- =doing-test-update-property=
- =doing-test-delete-entry=

* Phase 2: Core Capture and Lifecycle

The essential commands for logging activities.

** DONE Generate entry ID
:PROPERTIES:
:ID:       7E175ACC-807C-4360-BEB7-0F78C9E5B41B
:CLAUDE_TIME_MS: 124273
:CLAUDE_COST: 0.7101591999999999
:CLAUDE_INPUT_TOKENS: 70
:CLAUDE_OUTPUT_TOKENS: 4405
:CLAUDE_SESSION_ID: ac75f949-82d8-4568-b036-a7ff6e154189
:END:

Simple timestamp-based ID generation.

*** Implementation

#+BEGIN_SRC elisp
(defun doing--generate-id ()
  "Generate unique ID for entry."
  (format-time-string "%Y%m%dT%H%M%S"))
#+END_SRC

One line. No need for =org-id= complexity.

**** Tests

- =doing-test-generate-id-format=

** DONE =doing-now= — basic capture
:PROPERTIES:
:ID:       41AEFF81-BD39-4ED7-BE6C-3DB326D00362
:CLAUDE_TIME_MS: 152324
:CLAUDE_COST: 0.8357963500000003
:CLAUDE_INPUT_TOKENS: 44
:CLAUDE_OUTPUT_TOKENS: 5072
:CLAUDE_SESSION_ID: 321069d7-0698-4d57-bec5-258ec99ea708
:END:

Start a new activity.

*** Implementation

#+BEGIN_SRC elisp
;;;###autoload
(defun doing-now (title &optional tags)
  "Start new activity with TITLE and optional TAGS."
  (interactive "sWhat are you doing? ")
  (doing--ensure-directory)
  (let ((entry (list :id (doing--generate-id)
                     :title title
                     :tags tags
                     :started (doing--timestamp-now))))
    (doing--append-entry-to-file entry (doing--file-today))
    (message "Started: %s" title)))
#+END_SRC

**** Tests

- =doing-test-now-creates-entry=
- =doing-test-now-is-interactive=

** DONE =doing-current= — show current activity
:PROPERTIES:
:ID:       D8F1B991-DE20-4BB6-B68F-751B4872C33D
:CLAUDE_TIME_MS: 143933
:CLAUDE_COST: 0.8667437000000004
:CLAUDE_INPUT_TOKENS: 60
:CLAUDE_OUTPUT_TOKENS: 5651
:CLAUDE_SESSION_ID: 12b391c9-ca59-42ec-a4e1-57e8e7832524
:END:

Display unfinished activity.

*** Implementation

#+BEGIN_SRC elisp
(defun doing--current-entry ()
  "Return the current (unfinished) entry or nil."
  (let ((entries (doing--parse-file (doing--file-today))))
    (seq-find (lambda (e) (null (plist-get e :ended)))
              (reverse entries))))  ; most recent first

;;;###autoload
(defun doing-current ()
  "Show current activity in minibuffer."
  (interactive)
  (if-let ((entry (doing--current-entry)))
      (let* ((started (plist-get entry :started))
             (elapsed (doing--duration-minutes started (doing--timestamp-now)))
             (title (plist-get entry :title)))
        (message "[%s] %s" (doing--duration-format elapsed) title))
    (message "No activity in progress")))
#+END_SRC

**** Tests

- =doing-test-current-shows-active=
- =doing-test-current-when-nothing-active=

** DONE =doing-finish= — finish current activity
:PROPERTIES:
:ID:       99A7C8F4-B496-4AF8-AB30-A01C19ABCDB7
:CLAUDE_TIME_MS: 166839
:CLAUDE_COST: 0.7979882000000004
:CLAUDE_INPUT_TOKENS: 70
:CLAUDE_OUTPUT_TOKENS: 6200
:CLAUDE_SESSION_ID: 263a109e-4044-41df-9767-1db4ad49e6c3
:END:

Mark current activity complete using =org-entry-put=.

*** Implementation

#+BEGIN_SRC elisp
;;;###autoload
(defun doing-finish ()
  "Finish the current activity."
  (interactive)
  (if-let ((entry (doing--current-entry)))
      (let* ((id (plist-get entry :id))
             (title (plist-get entry :title))
             (started (plist-get entry :started))
             (ended (doing--timestamp-now))
             (duration (doing--duration-minutes started ended)))
        (doing--update-entry-property id "ENDED" ended)
        (doing--update-entry-property id "DURATION"
                                      (doing--duration-format duration))
        (message "Finished: %s (%s)" title (doing--duration-format duration)))
    (user-error "No activity in progress")))
#+END_SRC

**** Tests

- =doing-test-finish-sets-ended=
- =doing-test-finish-sets-duration=
- =doing-test-finish-error-when-no-current=

** DONE =doing-cancel= — cancel current activity
:PROPERTIES:
:ID:       A44F70FF-AA45-4612-A79E-8CE4D8DA4380
:CLAUDE_TIME_MS: 137236
:CLAUDE_COST: 0.8163093499999999
:CLAUDE_INPUT_TOKENS: 66
:CLAUDE_OUTPUT_TOKENS: 5321
:CLAUDE_SESSION_ID: b263ddb3-1ce8-4033-8cc9-eb52cf0c9ef6
:END:

Delete using =org-cut-subtree=.

*** Implementation

#+BEGIN_SRC elisp
;;;###autoload
(defun doing-cancel ()
  "Cancel the current activity."
  (interactive)
  (if-let ((entry (doing--current-entry)))
      (let ((id (plist-get entry :id))
            (title (plist-get entry :title)))
        (when (yes-or-no-p (format "Cancel \"%s\"? " title))
          (doing--delete-entry id)
          (message "Cancelled: %s" title)))
    (user-error "No activity in progress")))
#+END_SRC

**** Tests

- =doing-test-cancel-removes-entry=
- =doing-test-cancel-error-when-no-current=

** DONE =doing-note= — add note to current activity
:PROPERTIES:
:ID:       BFECDA3A-6D8A-4A41-961E-2C67AF9BF515
:CLAUDE_TIME_MS: 200397
:CLAUDE_COST: 0.8498905000000002
:CLAUDE_INPUT_TOKENS: 68
:CLAUDE_OUTPUT_TOKENS: 5882
:CLAUDE_SESSION_ID: 5ae6585f-f167-4999-ba4e-a8c0070cceb4
:END:

Append to entry body.

*** Implementation

#+BEGIN_SRC elisp
;;;###autoload
(defun doing-note (text)
  "Add TEXT as note to current activity."
  (interactive "sNote: ")
  (if-let ((entry (doing--current-entry)))
      (let ((id (plist-get entry :id)))
        (with-current-buffer (find-file-noselect (doing--file-today))
          (save-excursion
            (when (doing--goto-entry id)
              (org-end-of-meta-data t)
              (insert text "\n")
              (save-buffer))))
        (message "Note added"))
    (user-error "No activity in progress")))
#+END_SRC

**** Tests

- =doing-test-note-appends-text=
- =doing-test-note-error-when-no-current=

** DONE =doing-now= enhancement — auto-finish previous
:PROPERTIES:
:ID:       4E763D6D-4125-4B29-A2DB-9E5C0C4CA494
:CLAUDE_TIME_MS: 368194
:CLAUDE_COST: 1.3390986500000004
:CLAUDE_INPUT_TOKENS: 61
:CLAUDE_OUTPUT_TOKENS: 9791
:CLAUDE_SESSION_ID: faa91d6f-6983-4e8a-8a64-9c55400dcd43
:END:

Extend =doing-now= to auto-finish.

*** Implementation

Modify =doing-now= to call =doing-finish= first if there's an active entry:

#+BEGIN_SRC elisp
(defun doing-now (title &optional tags)
  "Start new activity with TITLE and optional TAGS."
  (interactive "sWhat are you doing? ")
  ;; Auto-finish previous if exists
  (when (doing--current-entry)
    (doing-finish))
  ;; ... rest of implementation
  )
#+END_SRC

**** Tests

- =doing-test-now-finishes-previous=

** DONE =doing-again= — resume last activity
:PROPERTIES:
:ID:       A7068322-7C72-4127-9B96-99B1D265DC2B
:CLAUDE_TIME_MS: 373318
:CLAUDE_COST: 1.7229269000000005
:CLAUDE_INPUT_TOKENS: 75
:CLAUDE_OUTPUT_TOKENS: 15999
:CLAUDE_SESSION_ID: 8aec7f94-5131-43a6-a86f-8b4a3c151119
:END:

Resume last finished activity.

*** Implementation

#+BEGIN_SRC elisp
(defun doing--last-finished-entry ()
  "Return the most recent finished entry."
  (let ((entries (doing--parse-file (doing--file-today))))
    (seq-find (lambda (e) (plist-get e :ended))
              (reverse entries))))

;;;###autoload
(defun doing-again ()
  "Resume the last finished activity."
  (interactive)
  (if-let ((entry (doing--last-finished-entry)))
      (doing-now (plist-get entry :title) (plist-get entry :tags))
    (user-error "No previous activity to resume")))
#+END_SRC

**** Tests

- =doing-test-again-copies-title-and-tags=
- =doing-test-again-error-when-no-previous=

* Phase 3: Rollover

Automatic migration of entries between files.

** DONE Daily rollover — today to week
:PROPERTIES:
:ID:       42E74054-5B6F-4A96-ACDB-6B32544B6A92
:CLAUDE_TIME_MS: 183601
:CLAUDE_COST: 0.9762961499999998
:CLAUDE_INPUT_TOKENS: 69
:CLAUDE_OUTPUT_TOKENS: 7156
:CLAUDE_SESSION_ID: 4d1dbf8f-4b61-4b7e-a1af-0ed01dad751b
:END:

Move old entries from =today.org= to =week.org=.

*** Implementation

#+BEGIN_SRC elisp
(defun doing--rollover-daily ()
  "Move entries from previous days to week.org."
  (let* ((today (format-time-string "%Y-%m-%d"))
         (entries (doing--parse-file (doing--file-today)))
         (old (seq-filter
               (lambda (e)
                 (not (string-prefix-p today (plist-get e :started))))
               entries)))
    (when old
      ;; Append old entries to week.org
      (dolist (entry old)
        (doing--append-entry-to-file entry (doing--file-week)))
      ;; Remove old entries from today.org
      (dolist (entry old)
        (doing--delete-entry (plist-get entry :id)))
      (length old))))
#+END_SRC

**** Tests

- =doing-test-rollover-daily-moves-old=
- =doing-test-rollover-daily-keeps-today=

** DONE Weekly rollover — week to archive
:PROPERTIES:
:ID:       75BAB323-51FB-4655-843C-673265DA1457
:CLAUDE_TIME_MS: 212860
:CLAUDE_COST: 1.18911035
:CLAUDE_INPUT_TOKENS: 80
:CLAUDE_OUTPUT_TOKENS: 10305
:CLAUDE_SESSION_ID: 22414bba-2a02-4b41-824b-76c1a9f70e9c
:END:

Archive old weeks.

*** Implementation

#+BEGIN_SRC elisp
(defun doing--rollover-weekly ()
  "Archive entries from previous weeks."
  (let* ((current-week (doing--iso-week))
         (entries (doing--parse-file (doing--file-week))))
    (dolist (entry entries)
      (let* ((started (plist-get entry :started))
             (entry-week (doing--iso-week
                          (encode-time
                           (org-parse-time-string started)))))
        (unless (equal entry-week current-week)
          ;; Archive this entry
          (let ((archive-file (doing--file-archive
                               (car entry-week) (cadr entry-week))))
            (doing--append-entry-to-file entry archive-file)
            (doing--delete-entry (plist-get entry :id)
                                 (doing--file-week))))))))
#+END_SRC

**** Tests

- =doing-test-rollover-weekly-archives=
- =doing-test-rollover-weekly-correct-filename=

** DONE Integrate rollover into commands
:PROPERTIES:
:ID:       D0ED89F8-A16A-403D-8BA1-AA71B2AB567C
:CLAUDE_TIME_MS: 232000
:CLAUDE_COST: 1.1379542999999999
:CLAUDE_INPUT_TOKENS: 63
:CLAUDE_OUTPUT_TOKENS: 8085
:CLAUDE_SESSION_ID: c9ef34a8-0ab5-4627-9c6e-617adf12dced
:END:

Call rollover lazily.

*** Implementation

#+BEGIN_SRC elisp
(defvar doing--last-rollover-time nil
  "Time of last rollover check.")

(defun doing--ensure-rollover ()
  "Perform rollover if needed (once per hour max)."
  (when (or (null doing--last-rollover-time)
            (> (float-time (time-subtract (current-time)
                                          doing--last-rollover-time))
               3600))  ; 1 hour
    (doing--rollover-daily)
    (doing--rollover-weekly)
    (setq doing--last-rollover-time (current-time))))
#+END_SRC

Add =(doing--ensure-rollover)= at start of =doing-now=, =doing-current=, views.

**** Tests

- =doing-test-ensure-rollover-throttled=

* Phase 4: View Commands

Display entries in temporary buffers.

** DONE View buffer infrastructure
:PROPERTIES:
:ID:       D22B3AF0-C497-4C42-B502-77C38BB9B150
:CLAUDE_TIME_MS: 236027
:CLAUDE_COST: 1.15506065
:CLAUDE_INPUT_TOKENS: 72
:CLAUDE_OUTPUT_TOKENS: 9779
:CLAUDE_SESSION_ID: 689b7bc7-788b-4ca5-82d4-60e961cc3207
:END:

Shared code for views.

*** Implementation

#+BEGIN_SRC elisp
(defun doing--view-buffer (name entries &optional group-fn)
  "Display ENTRIES in buffer *doing: NAME*.
Optional GROUP-FN groups entries (e.g., by date)."
  (let ((buf (get-buffer-create (format "*doing: %s*" name))))
    (with-current-buffer buf
      (let ((inhibit-read-only t))
        (erase-buffer)
        (org-mode)
        ;; Insert entries
        (if group-fn
            ;; Grouped display
            (dolist (group (seq-group-by group-fn entries))
              (insert (format "* %s\n" (car group)))
              (dolist (entry (cdr group))
                (insert (doing--format-entry-line entry))))
          ;; Flat display
          (dolist (entry entries)
            (insert (doing--format-entry-line entry))))
        ;; Insert totals
        (insert "\n---\n")
        (insert (format "Total: %s\n"
                        (doing--duration-format
                         (doing--sum-durations entries))))
        (goto-char (point-min))
        (view-mode 1)))
    (pop-to-buffer buf)))

(defun doing--format-entry-line (entry)
  "Format ENTRY as a single line for views."
  (let ((title (plist-get entry :title))
        (started (plist-get entry :started))
        (ended (plist-get entry :ended))
        (tags (plist-get entry :tags)))
    (format "- [%s] %s%s%s\n"
            (if ended
                (doing--duration-format
                 (doing--duration-minutes started ended))
              (doing--duration-format
               (doing--duration-minutes started (doing--timestamp-now))))
            title
            (if ended "" " *")
            (if tags (concat " :" (mapconcat #'identity tags ":") ":") ""))))

(defun doing--sum-durations (entries)
  "Sum durations of ENTRIES in minutes."
  (apply #'+
         (mapcar (lambda (e)
                   (let ((started (plist-get e :started))
                         (ended (or (plist-get e :ended)
                                    (doing--timestamp-now))))
                     (doing--duration-minutes started ended)))
                 entries)))
#+END_SRC

**** Tests

- =doing-test-view-buffer-created=
- =doing-test-sum-durations=

** DONE =doing-view-today=, =doing-view-yesterday=, =doing-view-week=
:PROPERTIES:
:ID:       73A9D4C0-E540-4CCD-95A6-579D95E7FA8A
:CLAUDE_TIME_MS: 349980
:CLAUDE_COST: 1.6242217500000007
:CLAUDE_INPUT_TOKENS: 83
:CLAUDE_OUTPUT_TOKENS: 12968
:CLAUDE_SESSION_ID: 67c98b3a-a230-44d0-8d72-55eed2e5cc75
:END:

Standard view commands.

*** Implementation

#+BEGIN_SRC elisp
;;;###autoload
(defun doing-view-today ()
  "Display today's activities."
  (interactive)
  (doing--ensure-rollover)
  (doing--view-buffer "today" (doing--parse-file (doing--file-today))))

;;;###autoload
(defun doing-view-yesterday ()
  "Display yesterday's activities."
  (interactive)
  (doing--ensure-rollover)
  (let* ((yesterday (format-time-string "%Y-%m-%d"
                      (time-subtract (current-time) (days-to-time 1))))
         (all-entries (append (doing--parse-file (doing--file-today))
                              (doing--parse-file (doing--file-week))))
         (filtered (seq-filter
                    (lambda (e)
                      (string-prefix-p yesterday (plist-get e :started)))
                    all-entries)))
    (doing--view-buffer "yesterday" filtered)))

;;;###autoload
(defun doing-view-week ()
  "Display this week's activities."
  (interactive)
  (doing--ensure-rollover)
  (let ((entries (append (doing--parse-file (doing--file-today))
                         (doing--parse-file (doing--file-week)))))
    (doing--view-buffer "this week" entries
                        (lambda (e) (doing--timestamp-date (plist-get e :started))))))
#+END_SRC

**** Tests

- =doing-test-view-today-shows-entries=
- =doing-test-view-week-groups-by-date=

** DONE =doing-view-recent= and =doing-view-since=
:PROPERTIES:
:ID:       655F91CC-A788-4820-BB0F-6908E9206D41
:CLAUDE_TIME_MS: 220761
:CLAUDE_COST: 1.2144657499999996
:CLAUDE_INPUT_TOKENS: 78
:CLAUDE_OUTPUT_TOKENS: 10098
:CLAUDE_SESSION_ID: e80e09be-5071-4d00-9976-177bcd91f786
:END:

Recent and date-range views.

*** Implementation

#+BEGIN_SRC elisp
;;;###autoload
(defun doing-view-recent (&optional n)
  "Display N most recent entries (default 10)."
  (interactive "P")
  (doing--ensure-rollover)
  (let* ((n (or n 10))
         (entries (append (doing--parse-file (doing--file-today))
                          (doing--parse-file (doing--file-week))))
         (sorted (seq-sort-by (lambda (e) (plist-get e :started))
                              #'string> entries))
         (recent (seq-take sorted n)))
    (doing--view-buffer "recent" recent)))

;;;###autoload
(defun doing-view-since (date)
  "Display entries since DATE."
  (interactive (list (org-read-date nil nil nil "Since: ")))
  (doing--ensure-rollover)
  (let* ((all-entries (append (doing--parse-file (doing--file-today))
                              (doing--parse-file (doing--file-week))))
         (filtered (seq-filter
                    (lambda (e)
                      (string>= (plist-get e :started)
                                (concat "[" date)))
                    all-entries)))
    (doing--view-buffer (format "since %s" date) filtered)))
#+END_SRC

Uses =org-read-date= for interactive date input!

**** Tests

- =doing-test-view-recent-limits=
- =doing-test-view-since-filters=

* Phase 5: Reports

Time totals and aggregation.

** DONE Duration aggregation utilities
:PROPERTIES:
:ID:       E8D5E1A4-2A3E-47E6-BC58-F861BE3E8C78
:CLAUDE_TIME_MS: 237206
:CLAUDE_COST: 1.2819026500000004
:CLAUDE_INPUT_TOKENS: 95
:CLAUDE_OUTPUT_TOKENS: 9159
:CLAUDE_SESSION_ID: ec8261b3-6405-4c06-ad20-6baeae00ad30
:END:

Group and sum by tag/project.

*** Implementation

#+BEGIN_SRC elisp
(defun doing--group-by-tag (entries)
  "Return alist of (TAG . ENTRIES) for each tag."
  (let ((result nil))
    (dolist (entry entries)
      (dolist (tag (plist-get entry :tags))
        (push entry (alist-get tag result nil nil #'equal))))
    result))

(defun doing--totals-by-tag (entries)
  "Return alist of (TAG . MINUTES) sorted by minutes desc."
  (let ((groups (doing--group-by-tag entries)))
    (seq-sort-by #'cdr #'>
                 (mapcar (lambda (g)
                           (cons (car g) (doing--sum-durations (cdr g))))
                         groups))))
#+END_SRC

**** Tests

- =doing-test-totals-by-tag=

** DONE =doing-totals=
:PROPERTIES:
:ID:       B15D2A7B-6B77-4B96-BB78-1885BA07BDC9
:CLAUDE_TIME_MS: 118146
:CLAUDE_COST: 0.6739041500000003
:CLAUDE_INPUT_TOKENS: 45
:CLAUDE_OUTPUT_TOKENS: 2930
:CLAUDE_SESSION_ID: 59cad59c-d449-45f2-911c-29c569bab023
:END:

Show time totals.

*** Implementation

#+BEGIN_SRC elisp
;;;###autoload
(defun doing-totals ()
  "Show time totals for this week by tag."
  (interactive)
  (doing--ensure-rollover)
  (let* ((entries (append (doing--parse-file (doing--file-today))
                          (doing--parse-file (doing--file-week))))
         (totals (doing--totals-by-tag entries))
         (buf (get-buffer-create "*doing: totals*")))
    (with-current-buffer buf
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert (format "Totals for %s\n\n" (doing--iso-week-string)))
        (insert "By tag:\n")
        (dolist (pair totals)
          (insert (format "  %-16s %s\n" (car pair)
                          (doing--duration-format (cdr pair)))))
        (insert "  ----------------\n")
        (insert (format "  %-16s %s\n" "Total"
                        (doing--duration-format
                         (doing--sum-durations entries))))
        (goto-char (point-min))
        (view-mode 1)))
    (pop-to-buffer buf)))
#+END_SRC

**** Tests

- =doing-test-totals-displays=

* Phase 6: Search (Optional org-ql integration)

Query and filter entries.

** DONE Basic search (no org-ql)
:PROPERTIES:
:ID:       5BD3BCDB-EFED-463E-A493-7609606BDCEF
:CLAUDE_TIME_MS: 237614
:CLAUDE_COST: 1.2253637000000002
:CLAUDE_INPUT_TOKENS: 114
:CLAUDE_OUTPUT_TOKENS: 10006
:CLAUDE_SESSION_ID: b19901e0-bf44-4a02-a8e9-70cde26d56a3
:END:

Simple text/tag search without org-ql.

*** Implementation

#+BEGIN_SRC elisp
(defun doing--entries-matching (predicate)
  "Return entries matching PREDICATE from today and week."
  (let ((entries (append (doing--parse-file (doing--file-today))
                         (doing--parse-file (doing--file-week)))))
    (seq-filter predicate entries)))

;;;###autoload
(defun doing-search (query)
  "Search entries matching QUERY (text or @tag)."
  (interactive "sSearch: ")
  (doing--ensure-rollover)
  (let* ((predicate
          (cond
           ;; @tag syntax
           ((string-prefix-p "@" query)
            (let ((tag (substring query 1)))
              (lambda (e) (member tag (plist-get e :tags)))))
           ;; Plain text
           (t (lambda (e)
                (string-match-p (regexp-quote query)
                                (plist-get e :title))))))
         (results (doing--entries-matching predicate)))
    (if results
        (doing--view-buffer (format "search: %s" query) results)
      (message "No entries matching \"%s\"" query))))
#+END_SRC

**** Tests

- =doing-test-search-by-text=
- =doing-test-search-by-tag=

** IDEA Enhanced search with org-ql

If =org-ql= is installed, provide richer queries.

*** Implementation (optional)

#+BEGIN_SRC elisp
(defun doing-search-ql (query)
  "Search with org-ql QUERY syntax."
  (interactive "sQuery (org-ql): ")
  (require 'org-ql)
  (org-ql-search (list (doing--file-today) (doing--file-week))
                 query))
#+END_SRC

This is optional and only available when org-ql is installed.

* Phase 7: Auto-tagging

Context-aware automatic tagging.

** DONE =doing-auto-tags= configuration
:PROPERTIES:
:ID:       B4519DF3-A942-4393-9871-14C29F390CDC
:CLAUDE_TIME_MS: 245586
:CLAUDE_COST: 1.0400215499999999
:CLAUDE_INPUT_TOKENS: 87
:CLAUDE_OUTPUT_TOKENS: 8378
:CLAUDE_SESSION_ID: c5a5ed70-7027-4dc3-aa1d-99ad95664b23
:END:

Directory-based tagging.

*** Implementation

#+BEGIN_SRC elisp
(defcustom doing-auto-tags nil
  "Alist mapping directory prefixes to tags/properties.
Example:
  ((\"~/projects/doing.el\" :project \"doing-el\" :tags (\"emacs\"))
   (\"~/projects/api\"      :project \"api\"      :tags (\"backend\")))"
  :type '(alist :key-type string
                :value-type (plist :key-type symbol :value-type sexp))
  :group 'doing)

(defun doing--auto-tags-for-directory (&optional dir)
  "Return auto-tags plist for DIR, or nil."
  (let ((dir (expand-file-name (or dir default-directory))))
    (cdr (seq-find (lambda (entry)
                     (string-prefix-p (expand-file-name (car entry)) dir))
                   (seq-sort-by (lambda (e) (length (car e))) #'>
                                doing-auto-tags)))))
#+END_SRC

**** Tests

- =doing-test-auto-tags-matching=

** DONE Integrate auto-tagging into =doing-now=
:PROPERTIES:
:ID:       4BA8D31C-DC16-43FF-9CE7-21FAEBFEF58D
:CLAUDE_TIME_MS: 175627
:CLAUDE_COST: 1.0580462999999998
:CLAUDE_INPUT_TOKENS: 58
:CLAUDE_OUTPUT_TOKENS: 4466
:CLAUDE_SESSION_ID: 87007489-dd60-4886-95bb-f25c6b7e892e
:END:

Apply auto-tags.

*** Implementation

Modify =doing-now=:

#+BEGIN_SRC elisp
(defun doing-now (title &optional tags)
  (interactive "sWhat are you doing? ")
  (when (doing--current-entry)
    (doing-finish))
  (doing--ensure-directory)
  ;; Get auto-tags
  (let* ((auto (doing--auto-tags-for-directory))
         (auto-tags (plist-get auto :tags))
         (project (plist-get auto :project))
         (all-tags (delete-dups (append tags auto-tags)))
         (entry (list :id (doing--generate-id)
                      :title title
                      :tags all-tags
                      :started (doing--timestamp-now)
                      :project project)))
    (doing--append-entry-to-file entry (doing--file-today))
    (message "Started: %s" title)))
#+END_SRC

**** Tests

- =doing-test-now-applies-auto-tags=
- =doing-test-now-applies-auto-project=

* Phase 8: Utility and Polish

Remaining commands.

** DONE =doing-last=, =doing-edit=, =doing-open=
:PROPERTIES:
:ID:       3BBD15C5-F604-42D6-BEBF-01742F5AD4B1
:CLAUDE_TIME_MS: 219328
:CLAUDE_COST: 0.9769451000000005
:CLAUDE_INPUT_TOKENS: 72
:CLAUDE_OUTPUT_TOKENS: 7042
:CLAUDE_SESSION_ID: d9a2d367-17c2-4173-b51d-9874eaf3e731
:END:

Utility commands.

*** Implementation

#+BEGIN_SRC elisp
;;;###autoload
(defun doing-last ()
  "Show last entry in minibuffer."
  (interactive)
  (let ((entries (doing--parse-file (doing--file-today))))
    (if-let ((entry (car (last entries))))
        (message "%s%s"
                 (plist-get entry :title)
                 (if (plist-get entry :ended) "" " *"))
      (message "No entries"))))

;;;###autoload
(defun doing-edit ()
  "Open today.org and jump to current entry."
  (interactive)
  (find-file (doing--file-today))
  (when-let ((entry (doing--current-entry)))
    (goto-char (plist-get entry :begin))
    (org-show-context)))

;;;###autoload
(defun doing-open (&optional file)
  "Open doing log FILE (default today)."
  (interactive
   (list (when current-prefix-arg
           (completing-read "File: "
                            '("today" "week")))))
  (find-file (pcase file
               ("week" (doing--file-week))
               (_ (doing--file-today)))))
#+END_SRC

**** Tests

- =doing-test-last-shows-entry=
- =doing-test-edit-opens-file=

** DONE Keybinding setup
:PROPERTIES:
:ID:       68608895-3CB3-4FE0-88C7-4728A0C95445
:CLAUDE_TIME_MS: 206519
:CLAUDE_COST: 0.9290635499999997
:CLAUDE_INPUT_TOKENS: 76
:CLAUDE_OUTPUT_TOKENS: 5924
:CLAUDE_SESSION_ID: 34d3bc40-d132-4ec4-858c-175087559fe9
:END:

Provide prefix keymap.

*** Implementation

#+BEGIN_SRC elisp
(defvar doing-command-map
  (let ((map (make-sparse-keymap)))
    (define-key map "n" #'doing-now)
    (define-key map "f" #'doing-finish)
    (define-key map "c" #'doing-current)
    (define-key map "a" #'doing-again)
    (define-key map "t" #'doing-view-today)
    (define-key map "w" #'doing-view-week)
    (define-key map "T" #'doing-totals)
    (define-key map "s" #'doing-search)
    (define-key map "e" #'doing-edit)
    (define-key map "o" #'doing-open)
    map)
  "Keymap for doing commands.
Suggested binding: (global-set-key (kbd \"C-c d\") doing-command-map)")
#+END_SRC

** DONE Package finalization
:PROPERTIES:
:ID:       8F547570-8467-43FE-AEE0-4ED1EC38D91E
:CLAUDE_TIME_MS: 225441
:CLAUDE_COST: 1.08463315
:CLAUDE_INPUT_TOKENS: 108
:CLAUDE_OUTPUT_TOKENS: 5298
:CLAUDE_SESSION_ID: 93b982dc-b07f-4605-ac3e-6234bc639456
:END:

Final cleanup.

*** Checklist

- [X] All public functions have docstrings
- [X] Autoload cookies on user-facing commands
- [X] Package headers complete
- [X] Byte-compiles without warnings
- [X] Tests pass


** TODO write README.org
:PROPERTIES:
:ID:       C0EB7E71-FB2E-48B7-AE54-C5DB07354070
:END:

Write a simple and comprehensive README file @README.org in org-mode format, introduce the tool, illustrate it's selling point, acknowledge that it's heavily inspired by the [[https://brettterpstra.com/projects/doing/][doing tool by Brett Terpstra]]. (It's basically a re-implementation in emacs with org-mode format). And illustrate it's usage.
